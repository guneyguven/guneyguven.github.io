
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Tango Oyunu</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #gameContainer {
            text-align: center;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #fff;
        }
        #themeSelector {
            margin: 10px 0;
            padding: 5px;
            font-size: 16px;
        }
        #controls {
            margin-top: 10px;
        }
        button {
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 16px;
            cursor: pointer;
        }
        .error {
            background-color: #ffcccc;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <select id="themeSelector">
            <option value="sunMoon">G√ºne≈ü & Ay (‚òÄÔ∏è/üåô)</option>
            <option value="starFlower">Yƒ±ldƒ±z & √ái√ßek (‚≠ê/üå∏)</option>
            <option value="catDog">Kedi & K√∂pek (üê±/üê∂)</option>
        </select>
        <canvas id="gameCanvas" width="360" height="360"></canvas>
        <div id="controls">
            <button onclick="generateNewPuzzle()">Yeni Bulmaca</button>
            <button onclick="getHint()">ƒ∞pucu</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const themeSelector = document.getElementById('themeSelector');
        const gridSize = 6;
        const cellSize = canvas.width / gridSize;
        let grid = [];
        let solution = [];
        let constraints = [];
        let currentTheme = { symbol1: '‚òÄÔ∏è', symbol2: 'üåô' };

        // Temalar
        const themes = {
            sunMoon: { symbol1: '‚òÄÔ∏è', symbol2: 'üåô' },
            starFlower: { symbol1: '‚≠ê', symbol2: 'üå∏' },
            catDog: { symbol1: 'üê±', symbol2: 'üê∂' }
        };

        // Yeni bulmaca olu≈ütur
        function generateNewPuzzle() {
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            solution = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            constraints = [];
            generateSolution();
            applyConstraints();
            initializeGrid();
            drawGrid();
        }

        // √á√∂z√ºlebilir bir √ß√∂z√ºm olu≈ütur
        function generateSolution() {
            let tempGrid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            function isValid(row, col, symbol) {
                // Satƒ±r ve s√ºtun kontrol√º
                let rowCount1 = tempGrid[row].filter(x => x === 1).length;
                let rowCount2 = tempGrid[row].filter(x => x === 2).length;
                let colCount1 = tempGrid.map(r => r[col]).filter(x => x === 1).length;
                let colCount2 = tempGrid.map(r => r[col]).filter(x => x === 2).length;
                if (rowCount1 >= 3 && symbol === 1 || rowCount2 >= 3 && symbol === 2) return false;
                if (colCount1 >= 3 && symbol === 1 || colCount2 >= 3 && symbol === 2) return false;

                // √ú√ßl√º kontrol
                if (col >= 2 && tempGrid[row][col-1] === symbol && tempGrid[row][col-2] === symbol) return false;
                if (col <= 3 && tempGrid[row][col+1] === symbol && tempGrid[row][col+2] === symbol) return false;
                if (row >= 2 && tempGrid[row-1][col] === symbol && tempGrid[row-2][col] === symbol) return false;
                if (row <= 3 && tempGrid[row+1][col] === symbol && tempGrid[row+2][col] === symbol) return false;

                return true;
            }

            function fillGrid(pos) {
                if (pos >= gridSize * gridSize) return true;
                let row = Math.floor(pos / gridSize);
                let col = pos % gridSize;
                let symbols = [1, 2];
                symbols.sort(() => Math.random() - 0.5);
                for (let symbol of symbols) {
                    if (isValid(row, col, symbol)) {
                        tempGrid[row][col] = symbol;
                        if (fillGrid(pos + 1)) {
                            solution = tempGrid.map(row => [...row]);
                            return true;
                        }
                        tempGrid[row][col] = null;
                    }
                }
                return false;
            }

            fillGrid(0);
        }

        // Kƒ±sƒ±tlamalar ekle
        function applyConstraints() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize - 1; j++) {
                    if (Math.random() < 0.2) {
                        constraints.push({ type: '=', r1: i, c1: j, r2: i, c2: j + 1 });
                    } else if (Math.random() < 0.2) {
                        constraints.push({ type: '√ó', r1: i, c1: j, r2: i, c2: j + 1 });
                    }
                }
                for (let j = 0; j < gridSize; j++) {
                    if (j < gridSize - 1 && Math.random() < 0.2) {
                        constraints.push({ type: '=', r1: j, c1: i, r2: j + 1, c2: i });
                    } else if (j < gridSize - 1 && Math.random() < 0.2) {
                        constraints.push({ type: '√ó', r1: j, c1: i, r2: j + 1, c2: i });
                    }
                }
            }
        }

        // Ba≈ülangƒ±√ß ƒ±zgarasƒ±nƒ± doldur
        function initializeGrid() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (Math.random() < 0.3) {
                        grid[i][j] = solution[i][j];
                    }
                }
            }
        }

        // Izgarayƒ± √ßiz
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let cellValid = isCellValid(i, j);
                    ctx.fillStyle = cellValid ? '#fff' : '#ffcccc';
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    if (grid[i][j]) {
                        ctx.fillStyle = '#000';
                        ctx.fillText(grid[i][j] === 1 ? currentTheme.symbol1 : currentTheme.symbol2, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
                    }
                }
            }

            // Kƒ±sƒ±tlamalarƒ± √ßiz
            ctx.fillStyle = '#000';
            constraints.forEach(c => {
                if (c.r1 === c.r2) {
                    ctx.fillText(c.type, (c.c1 + 0.5) * cellSize + cellSize / 2, c.r1 * cellSize + cellSize / 2);
                } else {
                    ctx.fillText(c.type, c.c1 * cellSize + cellSize / 2, (c.r1 + 0.5) * cellSize + cellSize / 2);
                }
            });

            if (checkWin()) {
                alert('Tebrikler! Bulmacayƒ± √ß√∂zd√ºn√ºz!');
            }
        }

        // H√ºcre ge√ßerliliƒüini kontrol et
        function isCellValid(row, col) {
            if (!grid[row][col]) return true;
            let rowCount1 = grid[row].filter(x => x === 1).length;
            let rowCount2 = grid[row].filter(x => x === 2).length;
            let colCount1 = grid.map(r => r[col]).filter(x => x === 1).length;
            let colCount2 = grid.map(r => r[col]).filter(x => x === 2).length;
            if (rowCount1 > 3 || rowCount2 > 3 || colCount1 > 3 || colCount2 > 3) return false;

            if (col >= 2 && grid[row][col-1] === grid[row][col] && grid[row][col-2] === grid[row][col]) return false;
            if (col <= 3 && grid[row][col+1] === grid[row][col] && grid[row][col+2] === grid[row][col]) return false;
            if (row >= 2 && grid[row-1][col] === grid[row][col] && grid[row-2][col] === grid[row][col]) return false;
            if (row <= 3 && grid[row+1][col] === grid[row][col] && grid[row+2][col] === grid[row][col]) return false;

            for (let c of constraints) {
                if (c.r1 === row && c.c1 === col) {
                    if (c.type === '=' && grid[c.r1][c.c1] !== grid[c.r2][c.c2] && grid[c.r2][c.c2] !== null) return false;
                    if (c.type === '√ó' && grid[c.r1][c.c1] === grid[c.r2][c.c2] && grid[c.r2][c.c2] !== null) return false;
                } else if (c.r2 === row && c.c2 === col) {
                    if (c.type === '=' && grid[c.r1][c.c1] !== grid[c.r2][c.c2] && grid[c.r1][c.c1] !== null) return false;
                    if (c.type === '√ó' && grid[c.r1][c.c1] === grid[c.r2][c.c2] && grid[c.r1][c.c1] !== null) return false;
                }
            }
            return true;
        }

        // Kazanma kontrol√º
        function checkWin() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] !== solution[i][j]) return false;
                    if (!isCellValid(i, j)) return false;
                }
            }
            return true;
        }

        // ƒ∞pucu ver
        function getHint() {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === null) {
                        grid[i][j] = solution[i][j];
                        drawGrid();
                        return;
                    }
                }
            }
        }

        // Tƒ±klama olayƒ±
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            if (grid[row][col] === null) {
                grid[row][col] = 1;
            } else if (grid[row][col] === 1) {
                grid[row][col] = 2;
            } else {
                grid[row][col] = null;
            }
            drawGrid();
        });

        // Tema deƒüi≈ütirme
        themeSelector.addEventListener('change', () => {
            currentTheme = themes[themeSelector.value];
            drawGrid();
        });

        // Oyunu ba≈ülat
        generateNewPuzzle();
    </script>
</body>
</html>